#!/usr/bin/env bash

# This script will push specified local changes to the specified remote branch on GitHub.
# It always tries to pull from specified branch and push to specified branch no matter what local branch youre on
# It is safe to run multiple times if errors occur as it will prompt before changing something important.
# It takes two arguments:
#   path: path to the file or directory you want to 'git add'
#   message: a string representing the commit message (ie. "fixed some bug")
# You must execute this script from a local git repository
# Complete Usage: 
#   (on Unix or in git-bash)
#   ./git-push <path> "<message>" <remote-branch-name?= 'main'>
# 

# First time setup using git-push
# Commands:
# Unix:
#     cd <path-on-your-computer>
#     curl https://raw.githubusercontent.com/mzamora1/CSE-360-Team-Project/main/git-push | bash -s -- --init-gpg
 
# Windows:
#     (in cmd or Powershell)
#     start "C:\ProgramFiles\Git\git-bash.exe"
#     (now use Unix command above inside git-bash)
# 
# First time setup will not push anything to GitHub. It will only walk you through configuring
# git so that you can then push to GitHub manually or by rerunning this script with 
# the correct arguments. It will also help set up commit verification using gpg.


red() { printf "\e[1;31m$1\e[0m"; }
green() { printf "\e[1;32m$1\e[0m"; }
yellow() { printf "\e[1;33m$1\e[0m"; }
purple() { printf "\e[1;35m$1\e[0m"; }
warning() { printf "$( yellow "WARNING" ): $1\n"; }
success() { printf "$( green "SUCCESS" ): $1\n"; }
error() {
    printf "$( red "ERROR" ): $1\n"
    return 1
}
askYesNo() {
    printf "$1\n(yes/no): "
    read CHOICE <&1
    case $CHOICE in 
        yes | y | Y | YES | 1) 
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

assert() {
    # echo $1
    if ! [ $1 ]; then
        error "$2"
        until [ -z "$3" ]; do  # Until all parameters used up . . .
            echo "$3"
            shift
        done
        exit 1
    fi
}
assertOk() { assert "$? -eq 0" $@; }


REPO_NAME="CSE-360-Team-Project"
USAGE="$( purple "Usage" ): ./git-push <path> \"<message>\" <remote-branch-name?= 'main'>\n\tpath: single path to files you want to 'git add'\n\tmessage: string representing commit message (must include \"\" if multiworded)\n\tremote-branch-name: name of branch to push to (optional, defaults to main branch)\n"
CORRECT_ORIGIN="https://github.com/mzamora1/$REPO_NAME.git"
CWD=$( pwd )

GIT_VERSION=$( git --version )
assertOk "could not find git" "Install git for your platform from 'https://git-scm.com/downloads' and make sure it is added to your \$PATH"

if ! [ -d "$CWD/.git" ]; then
    askYesNo "$( warning "current working directory does not point to a local git repository\nDo you want to clone the repository into its own folder in this directory?" )"
    assertOk "rerun in a local git repository"
    git clone $CORRECT_ORIGIN
    success "cloned $REPO_NAME to '$CWD/$REPO_NAME'"
    echo "Use 'cd $REPO_NAME' to work in the local repository."
    cd "$REPO_NAME"
fi

LOCAL_BRANCH=$( git branch --show-current )
NAME=$( git config --get user.name )
EMAIL=$( git config --get user.email )
SIGNING_KEY=$( git config --get user.signingkey )
ORIGIN=$( git config --get remote.origin.url )

if [ ! $? -eq 0 ]; then
    echo "$( yellow 'adding remote origin' ): $CORRECT_ORIGIN"
    git remote add origin "$CORRECT_ORIGIN"
elif [ "$ORIGIN" != "$CORRECT_ORIGIN" ]; then
    askYesNo "$( warning "Your remote origin does not point to $REPO_NAME\nDo you want to set it back to deafult ($CORRECT_ORIGIN)?" )"
    if [ $? -eq 0 ]; then 
        git remote set-url origin "$CORRECT_ORIGIN"
        echo "$( yellow 'set remote origin' ): $CORRECT_ORIGIN"
    else echo "ok continuing..."
    fi
fi


set_config() {
    git config --global "$1" "$2"
    echo "$( yellow "set '$1'" ): $2"
}
if [ -z "$NAME" ]; then
    read -p "Enter your first and last name. ex. 'John Smith' (used in commit msg): " NAME <&1
    set_config user.name "$NAME"
fi

if [ -z "$EMAIL" ]; then
    read -p "Enter your GitHub no-reply email (used in commit msg): " EMAIL <&1
    set_config user.email "$EMAIL"
fi

if [ "$LOCAL_BRANCH" != "main" ]; then
    askYesNo "$( warning "you're about to push to the main branch while working on local branch: '$LOCAL_BRANCH'\nDo you want to switch back to main branch? No will continue executing")"
    if [ $? -eq 0 ]; then
        LOCAL_BRANCH="main"
        git fetch --all
        git checkout -b "$LOCAL_BRANCH" origin/main
        assertOk "failed to checkout main branch, see output above"
        echo "$( yellow 'switched to main branch' )"
    fi
    echo "ok continuing..."
fi

export GPG_TTY=$(tty)

extract_keys() { gpg --list-keys --keyid-format LONG $@; }
extract_keyid() {
    extract_keys $@ | grep "^pub\|^sec" | cut -d'/' -f 2 | cut -d' ' -f 1
}
extract_keyalgo() {
    extract_keys $@ | grep "^pub\|^sec" | cut -d'/' -f 1 | cut -d' ' -f 4
}
set_signingkey() {
    set_config user.signingkey $1
    set_config commit.gpgsign 'true'
}

init_gpg() {
    GPG_VERSION_INFO=$( gpg --version )
    assertOk "could not find gpg" "If its NOT installed, rerun without '--init-gpg' flag" \
    "If it is installed, make sure it is added to your \$PATH"
    KEY_USER=$( extract_keys | grep "$NAME.\+$EMAIL" )
    if [ -n "$KEY_USER" ]; then
        warning "already created gpg key for '$NAME' <$EMAIL>\nDo you want to..."
        PS3="Enter a number above: "
        SIGNING_KEY=$( extract_keyid "$NAME" "$EMAIL" )
        select CHOICE in "use key id: $SIGNING_KEY" "make another key" "quit and exit"; do
            case $CHOICE in
                "use key id: $SIGNING_KEY")
                    if [ "$( extract_keyalgo $SIGNING_KEY )" != "rsa4096" ]; then
                        askYesNo "$( warning "key id($SIGNING_KEY) does not use default algo 'rsa4096' so it may not work correctly with github.\nDo you still want to set it as your signing key?" )"
                        assertOk "rerun with '--init-gpg' to make a new key"
                    fi
                    set_signingkey $SIGNING_KEY
                    exit 0
                    ;;
                "make another key")
                    echo "ok continuing..."
                    ;;
                *)
                    error "rerun without '--init-gpg' flag"
                    exit 0
                    ;;
            esac
            break
        done
    fi
    echo "Configuring a new gpg key..."
    read -p "Enter a passphrase for this key that you will remember: " PASSPHRASE <&1
    COMMENT="Gen by git-push on $( date )"
    gpg --default-new-key-algo rsa4096 --gen-key --batch <<GPGConfig
%echo Creating gpg key...
Key-Type: 1
Key-Length: 4096
Subkey-Type: 1
Subkey-Length: 4096
Name-Real: $NAME
Name-Comment: $COMMENT
Name-Email: $EMAIL
Expire-Date: 0
Passphrase: $PASSPHRASE
%commit
%echo Finished creating key.
GPGConfig
    assertOk "could not generate keys, see output above." \
    "gpg is optional, so if this is too much of a pain then dont include '--init-gpg' argument."
    SIGNING_KEY=$( extract_keyid "$COMMENT" )
    printf "\n$( purple "Public GPG Key" ): \n\n"
    gpg --armor --export $SIGNING_KEY
    printf "\n\n$( purple Instructions ):\n\t1. Sign into GitHub.com\n\t2. Go to your profile settings and find where it says 'GPG keys'\n\t3. Click 'New GPG key'\n\t4. Copy the whole block of text above from ---BEGIN--- to ---END--- into the prompt and add key.\n\t5. Once done, press ENTER to continue\n"
    read CHOICE <&1
    set_signingkey $SIGNING_KEY
    echo "To stop using verified commits use 'git config --global commit.gpgsign 'false''"
    success "configured git and gpg. Use 'cd $REPO_NAME' and start making verified commits!"
    echo "$USAGE"
    exit 0
}


if [ "$1" == "--init-gpg" ]; then
    init_gpg
fi

# end of setup


if [ "$(git config --get commit.gpgsign )" == "true" ]; then
    KEY_USER=$( extract_keys $SIGNING_KEY | grep "$NAME.\+$EMAIL" )
    if [ -z "$KEY_USER" ]; then
        error "Current user (name: '$NAME', email: '$EMAIL') does not match current signing key-id (signingkey: $SIGNING_KEY)"
        echo "Change git user configuration or create a new key for this user using './git-push --init-gpg'"
        echo "If errors still occur after making a new key then disable verified commits with 
        'git config --global commit.gpgsign 'false''"
        exit 1
    fi
fi

if [ $# -gt 3 ] || [ $# -lt 2 ]; then 
    error "incorrect usage"
    printf "$USAGE"
    exit 1
fi

if [ -z "$2" ]; then 
    error "commit message must not be empty"
    exit 1
fi

REMOTE_BRANCH=$( [ -n "$3" ] && echo "$3" || echo main )
REMOTE_BRANCHS=$( git branch -r )
if [ -z "$( echo "$REMOTE_BRANCHS" | grep -F "origin/$REMOTE_BRANCH" )" ]; then
    error "cannot find remote branch 'origin/$REMOTE_BRANCH'"
    exit 1
fi


git pull origin main
assertOk "could be from conflicting merge between main branch and local repository" \
"Solution: use 'git mergetool' or 'git diff' to find and correct each merge conflict." \
"Solution: if you want to overwrite all local conflicts with remote state use 'git pull --force origin main'" \
"Solution: if you want to overwrite all remote conflicts with local state use 'git add . && git commit -m \"message\" && git push origin main'" \
"Solution: Google how to resolve git merge conflicts"
success "fetched and merged main branch"

git add "$1" && success "added '$1'" && \
git commit -m  "$2" && success "commited '$2'" && \
git push origin "$LOCAL_BRANCH:$REMOTE_BRANCH" && success "pushed to main branch" || error "failed to push to main branch, see output above"

exit $?